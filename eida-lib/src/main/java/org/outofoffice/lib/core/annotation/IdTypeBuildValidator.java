package org.outofoffice.lib.core.annotation;

import com.google.auto.service.AutoService;
import org.outofoffice.lib.util.ClassUtils;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static java.util.stream.Collectors.toMap;

@AutoService(Processor.class)
public class IdTypeBuildValidator extends AbstractProcessor {
    private static final Set<Class<?>> AUTO_GENERATE_CLASSES = Set.of(Long.class);
    private static final Set<Class<?>> ACCEPT_CLASSES = Set.of(Long.class, String.class);

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(Id.class.getName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        Set<? extends Element> fields = roundEnvironment.getElementsAnnotatedWith(Id.class);
        for (Element field : fields) {
            TypeMirror fieldType = field.asType();
            Class<?> fieldClass = ClassUtils.classForName(fieldType.toString());

            if (!ACCEPT_CLASSES.contains(fieldClass)) {
                notifyError(fieldClass, "Not in" + ACCEPT_CLASSES);
                return true;
            }

            List<? extends AnnotationMirror> fieldAnnotations = field.getAnnotationMirrors();

            AnnotationMirror targetAnnotation = fieldAnnotations.stream()
                .filter(fieldAnnotation -> annotationClass(fieldAnnotation).equals(Id.class))
                .findFirst().orElseThrow();

            Map<String, String> valueMap = targetAnnotation.getElementValues().entrySet().stream()
                .collect(toMap(e -> e.getKey().toString(), e -> e.getValue().toString()));
            boolean autoGenerated = Boolean.parseBoolean(valueMap.get("autoGenerated()"));


            if (autoGenerated && !AUTO_GENERATE_CLASSES.contains(fieldClass)) {
                notifyError(fieldClass, "Not in " + AUTO_GENERATE_CLASSES);
            }
        }
        return true;
    }

    private Class<?> annotationClass(AnnotationMirror fieldAnnotation) {
        DeclaredType annotationType = fieldAnnotation.getAnnotationType();
        String annotationClassName = annotationType.toString();
        return ClassUtils.classForName(annotationClassName);
    }

    private void notifyError(Class<?> clazz, String s) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, s + "(" + clazz + ")");
    }
}
